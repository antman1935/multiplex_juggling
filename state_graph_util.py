import networkx as nx
from itertools import permutations
from sage.all import Partitions

"""
This class represents a magic multiplex juggling state with hand capacity m.
"""
class State:
    """
    Constructs magic multiplex juggling state with the balls in a configuration as described by the parameter "state".
    """
    def __init__(self, state, m):
        self.state = removeTrailingZeros(state)
        self.m = m
        
        for x in self.state:
            assert x <= self.m
            
    """
    Returns the greatest number of balls at any single height in the state.
    """
    def maxNumberOfBalls(self):
        return max(self.state)
            
    """
    This is always equivalent to the height of the state, the greatest height that has a nonzero number of balls in the state.
    """
    def __len__(self):
        return len(self.state)
    
    """
    Hashing function for the purpose of use in dicts.
    """
    def __hash__(self):
        return hash(str(self.state))

    def __eq__(self, other):
        return str(self) == str(other)
            
    """
    This method simulates a time step in a juggling sequence. This returns the intermediate juggling state gotten by shifting the state's balls' heights down by one, along with the number of balls that would have fallen in that shift. That way, a valid state that could follow this one could be generated by taking the returned intermediary juggling state and distributing the returned number of balls over it.
    """
    def shiftDown(self):
        newState = self.state[1:]
        value = 0
        if len(self.state) > 0:
            value = self.state[0]
            
        return State(newState, self.m), value
    
    """
    In line with using `shiftDown` to generate valid adjacent juggling states, this allows us to take the generated intermediate juggling state and a transition array, an array of nonnegative integers representing a distribution of balls, and return the next state in this sequence.
    """
    def applyTransition(self, transitionArray):
        newState = []
        for i in range(0, min(len(self.state), len(transitionArray))):
            newValue = self.state[i] + transitionArray[i]
            if newValue > self.m:
                return None
            newState.append(newValue)
            
        if len(self.state) > len(transitionArray):
            newState = newState + self.state[len(transitionArray):]
        elif len(transitionArray) > len(self.state):
            newState = newState + transitionArray[len(self.state):]
            
        return State(newState, self.m)
    
    """
    Formats to print to the screen. For latex formating, repace the carrots with \rangle and \langle.
    """
    def __str__(self):
        return str(self.state).replace("[", "<").replace("]", ">")
    
    """
    This function generates a tikz picture that represents the state.
    """
    def getTikzPicture(self, x_offset = 0, bars = 0, m = 0, arrow = True):
        assert(bars > 0 and m > 0)
        width = (m - 1) * 0.3 + 0.4
        stem_height = (bars + 1) / 4.0
        tikz_code = "\\draw (" + str(x_offset) + ",-" + str(stem_height) + ") -- (" + str(x_offset) + "," + str(stem_height) + ");\n"
        
        height = -stem_height + 0.5
        for bar in range(0, bars):
            tikz_code += "\\draw (" + str(x_offset) + ", " + str(height) + ") -- (" + str(x_offset + width) + ", " + str(height) + ") -- (" + str(x_offset + width + 0.5) + ", " + str(height +0.5) + ");\n"
            if bar < len(self.state):
                ball_x_pos = 0.2 + x_offset
                ball_y_pos = height + 0.2
                
                if self.state[bar] < 0:
                    drawMode = "draw"
                    count = -self.state[bar]
                else:
                    drawMode = "fill"
                    count = self.state[bar]
                
                for i in range(count):
                    tikz_code += "\\" + drawMode + " (" + str(ball_x_pos) + "," + str(ball_y_pos) + ") circle (3pt);\n"
                    ball_x_pos += 0.3
            
            height += 0.5
            
        tikz_code += "\\draw (" + str(x_offset) + ", " + str(-height -0.5) + ") node {$" + str(self).replace("<", "\langle").replace(">", "\rangle") + "$};\n"
        if arrow:
            tikz_code += "\\draw[->] (" + str(x_offset + width + 0.8) + ",0) -- (" + str(x_offset + width + 1.3) + ",0);"
        
        return tikz_code
    
"""
Method returns the sublist of the paramter `arr` that ends at the last nonzero element of the array `arr`, inclusive.
"""
def removeTrailingZeros(arr):
    if len(arr) == 0:
        return arr
    for i in range(len(arr)-1, -1, -1):
        if arr[i] != 0:
            return arr[:i+1]
        
    return []
    
"""
There are a finite number of transition arrays, i.e. arrays of nonnegative integers representing a redistribution of some balls, when we restrict the maximum height to which the balls can be thrown. This function computes all such arrays for all numbers of balls less than the hand capacity `capacity`.
"""
def getValidTransitions(capacity, maxHeight):
    transitions = {}
    for i in range(0, capacity+1):
        transitions[i] = []
        partitions = Partitions(i)
        heightCorrectedPartitions = [[0 if j >= len(partition) else partition[j] for j in range(0, maxHeight)] for partition in partitions if len(partition) <= maxHeight]
        for partition in heightCorrectedPartitions:
            previous = tuple()
            for p in permutations(sorted(partition), maxHeight):
                if p > previous:
                    previous = p
                    transitions[i].append(removeTrailingZeros(list(p)))
                    
    return transitions

"""
Given a map of transitions generated from the function `getValidTransitions`, this removes all the transitions that redistribute balls higher than the height given in the parameter `maxHeight`.
"""
def shedTransitions(transitions, maxHeight):
    for i in transitions:
        transitions[i] = [transition for transition in transitions[i] if len(transition) <= maxHeight]
        
"""
This is the only function that needs to be called to generated magic multiplex juggling sequences. This computes MJS(s,e,m,n) and returns the value as a list of sequences (lists) of State objects.

@Parameter - start: array of integers representing the starting state of the sequences.
@Parameter - end: array of integers representing the ending state of the sequences.
@Parameter - capacity: positive integer, maximum hand capacity of each state in each sequence.
@Parameter - length: positive integer, the length of every sequence we return.
"""
def getMultiplexJugglingSequences(start, end, capacity, length):
    return getMultiplexJugglingSequencesHelper(State(start, capacity), State(end, capacity), capacity, length)
        
"""
Helper function used to actually do the computations for `getMultiplexJugglingSequences`.
"""
def getMultiplexJugglingSequencesHelper(start, end, capacity, length):
    maxHeight = len(end) + length - 1
    frontier = [[start]]
    newFrontier = []
    validTransitions = getValidTransitions(capacity, maxHeight)
    
    while maxHeight >= len(end):
        print [[str(y) for y in x] for x in frontier]
        for path in frontier:
            lastState = path[len(path) - 1]
            base, balls = lastState.shiftDown()
            
            if balls >=0:
                transitions = validTransitions[balls]
                for transition in transitions:
                    newState = base.applyTransition(transition)
                    if newState != None:
                        newFrontier.append(path + [newState])
                    
        maxHeight -= 1
        frontier = newFrontier
        newFrontier = []
        shedTransitions(validTransitions, maxHeight)
        
    return [path for path in frontier if path[len(path) - 1] == end]

"""
Given a sequence generated from `getMultiplexJugglingSequences`, i.e. an array of State objects, this creates a tikz picture representing that sequence.
"""
def drawJugglingSequence(sequence):
    tikz = "\\begin{tikzpicture}\n"
    width = 0
    bars = 0
    for state in sequence:
        width = max(width, state.maxNumberOfBalls())
        bars = max(bars, len(state))
    bars = max(bars, 5) # default to 5 bars at least
    x_offset = 0
    delta_x = (width - 1) * 0.3 + 2.2
    for i in range(len(sequence)):
        state = sequence[i]
        tikz += state.getTikzPicture(x_offset = x_offset, bars = bars, m = width, arrow = i != len(sequence) - 1) + ("\n" if i != len(sequence) - 1 else "")
        x_offset += delta_x
        
    tikz += "\end{tikzpicture}"
    return tikz
        
######### Everything past this point was for visualizing finite portions of the state graph. It is experimental
def constructStateGraph(baseState, finalState, m, length):
    maxHeight = length + len(baseState) - 1
    graph = {str(baseState): set()}
    validTransitions = getValidTransitions(m, maxHeight)
    frontier = [baseState]
    
    while len(frontier) > 0 and maxHeight >= len(baseState):
        newFrontier = []
        
        for state in frontier:
            base, i = state.shiftDown()
            transitions = validTransitions[i]
            
            for transition in transitions:
                newState = base.applyTransition(transition)
                if newState != None:
                    strRep = str(newState)
                    graph[str(state)].add(strRep)
                    if not strRep in graph:
                        graph[strRep] = set()
                        newFrontier.append(newState)
                        
        frontier = newFrontier
        maxHeight = maxHeight - 1
        shedTransitions(validTransitions, maxHeight)
        
    return graph

def convertGraphToNetworkXGraph(graph):
    xGraph = nx.DiGraph()
    xGraph.add_nodes_from(graph.keys())
    for node in graph:
        for dest in graph[node]:
            xGraph.add_edge(node, dest)
            
    return xGraph
